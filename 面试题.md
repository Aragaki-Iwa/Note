1.一只青蛙一次可以跳上1级台阶，也可以跳上2级。求该青蛙跳上一个n级的台阶总共有多少种跳法（先后次序不同算不同的结果）
实际就是斐波那契数列，f[n] = f[n-1]+f[n-2] n>2.递归的话会有太多重复计算，速度慢，用迭代    
```
int jumpFloor(int n)
{
    
    if(n==0||n==1||n==2)
    {
      return n;
    }
    int sum = 0;
    int t1 = 1;
    int t2 = 2;
    while(n>2)
    {
      sum = t1 + t2;
      t1 = t2;
      t2 = sum;
      --n;
    }
    return sum;
}
```
2.二叉树相关  
```
struct TreeNode
{
    int val;
    struct TreeNode* left;
    struct TreeNode* right;
    TreeNode(int x):val(x),left(NULL),right(NULL){}
};
```
2.1 从上往下打印出二叉树的每个节点，同层节点从左至右打印  
```   
vector<int> PrintFromTopToBottom(TreeNode* root)
{
    //用队列
    vector<int> nodes;
    queue<TreeNode*> que;
    
    que.push(root);
    while(!que.empty())
    {
        root = que.front();que.pop();
        if(root==NULL)
            continue;
        nodes.push_back(root->val);
        que.push(root->left);
        que.push(root->right);
    }
    return nodes;
}
```
2.2二叉树深度：从根结点到叶结点依次经过的结点（含根、叶结点）形成树的一条路径，最长路径的长度为树的深度
分析：实际就是有多少层，那么显然可以采用广度优先遍历  
 ``` 
int TreeDepth(TreeNode* root)
{
    if(root==NULL)
        return 0;  //若输入为空则深度为0；
    queue<TreeNode*> que;
    TreeNode* temp;
    int depth = 0;
    
    que.push(root);
    while(!que.empty())
    {
        ++depth;
        for(int i = 0; i < q.size(); ++i) {
            temp = que.front(); que.pop();
            if(temp->left)
                que.push(temp->left);
            if(temp->right)
                que.push(temp->right);
        }
    }
    return depth;
}
```
3.链表相关
```
struct ListNode
{
    int val;
    struct ListNode* next;
    ListNode(int x):val(x),next(NULL){}
}
```
经常用到：找链表中间结点
```
ListNode* find_mid_listnode(ListNode* head)
{
    if(head==NULL||head->next==NULL)
        return head;
    ListNode *prev = head->next; //这里
    ListNode *follow = head;
    while(!prev || !prev->next) //与这里相对应，若上面是prev = head,则这里是!prev->next || !prev->next->next
    {
        prev = prev->next->next;
        follow = follow->next;
    }
    return follow;
}
```
3.1反转链表，输出新的表头
```
ListNode* ReverseList(ListNode* head)
{
    if(head==NULL||head->next==NULL)
        return head;
    ListNode* prev = head;
    ListNode* cur = head->next;
    head->next = NULL; //反转头结点
    
    ListNode* next;
    while(cur)
    {
        next = cur->next; //先保留下一个，为了下一次迭代
        cur->next = prev;
        //往前推进
        prev = cur;
        cur = next;
    }
    //跳出循环，说明cur = NULL,则prev为tail
    return prev;
}
```
3.2输出链表中倒数第k个结点
```
ListNode* FindKthToTail(ListNode* head, int k)
{
    if(head==NULL)
        return head;
    ListNode *prev = head;
    ListNode *follow = head;
    int length = 0; //记录链表总长度
    int num = k;
    while(prev)
    {
        prev = prev->next;
        ++length;
        if(num-- < 1) { //当prev到达k-1时，follow出发
            follow = follow->next;
        }
    }
}


